# 3장 저장소와 검색

데이터를 저장하는 방법에 대한 설명

### 색인
- 색인은 기본데이터에서 파생된 추상적인 구조.
- 색인이 늘어나면 쓰기 성능에 영향을 미친다.
- 색인이 있으면 읽기 성능이 향상된다.
  트레이드 오프가 필요

### 해시 색인
프로그래밍 언어의 Dictionary Type 과 비슷

- 파일에 데이터를 추가하는 방식인 경우
  - 키를 데이터 파일의 바이트 오프셋에 매핑하여 관리
  - 디스크 공간이 부족해지느 경우 특정 크기의 세그먼트로 나누고, 세그먼트 파일들을 컴팩션하며 최신값만 유지

Bitcask - 해시 맵을 전부 메모리에 유지. 키 값이 자주 갱신되는 상황에 매우 적합

#### 장점
 - 추가와 세그먼트 병합은 순차적인 쓰기 작업
 - 세그먼트 파일이 추가 전용이나 불변이면 동시성과 고장 복구에 유리
 - 데이터 조각화를 피할 수 있음

#### 단점
 - 해시 테이블을 메모리에 저장해야 하기 때문에 키가 많으면 문제가 된다
 - 디스크에 해시 맵을 저장하는 경우 성능이 좋지 않음. random read 가 발생
 - range query에 효율적이지 않음

## SS테이블과 LSM 트리
 - 위 해시색인의 세그먼트 파일 형식에 키-값 쌍을 키로 정렬하는 것.
 - 이처럼 키로 정렬된 형식을 SS테이블 이라 부른다. (Sorted String Table)
 - 정렬된 키 테이블이 있으면 메모리에 모든 키의 색인을 유지할 필요가 없음
    일부를 희소 색인(sparse index)으로 유지하면 그 사이에 있는 값은 탐색으로 찾을 수 있음.
     (모든 세그먼트 크기가 고정이라면 이진탐색을 쓸 수 있음 -> 희소 색인이 필요 없다)
 - 희소 색인 사이의 데이터를 디스크에 압축해서 저장할 수 있음.

#### SS테이블 생성과 유지
쓰기가 임의 순서로 유입될 때 데이터를 키로 정렬하려면 어떻게 해야 할까?
 -> 레드 블랙 트리나 AVL트리를 사용

- 쓰기가 들어오면 인 메모리 균형 트리(balanced tree) 데이터 구조를 추가한다. 멤테이블(memtable)이라고 한다.
  - 멤테이블이 임곗값보다 커지면 SS테이블 파일로 디스크에 기록한다.
     디스크에 쓰는동안 쓰기는 새로운 멤테이블 인스터스에 한다.
  - 읽기 요청을 제공할 때 멤테이블에서 키를 찾는다. 
     그 다음 가장 최신 세그먼트에서 찾고. 차순 세그먼트에서 나올 때까지 찾는다.

**단점**
 - 데이터베이스가 고장나면 멤테이블에 있는 가장 최신 쓰기는 손실된다
    -> 최신 쓰기 정보를 디스크에 쓴다. 복원용이기 때문에 정렬은 필요없다

### LSM 트리
Log-Structured Merge-Tree
정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진을 LSM 저장소 엔진이라 부른다
LSM 트리의 기본 개념은 백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합하는것
이 접근법은 sequencial write이기 때문에 높은 쓰기 처리량을 보장

루씬(Lucene. 엘라스틱서치나 솔라에서 사용하는 전문 검색 색인 엔진)은 용어사전(term dictionary)을 저장하기 위해 유사한 방법을 사용.
키를 단어(용어)로 값은 단어를 포함한 모든 문서의 ID목록(포스트 목록)으로 하는 키-값 구조로 구현한다. 루씬에서 용어와 포스팅 목록은 SS테이블 같은 정렬 파일에 유지한다.

#### 성능 최적화
LSM 트리 알고리즘은 존재하지 않는 키를 찾을 때 느리다.
이런 접근을 최적화하기 위해 블룸 필터(Bloom filter)를 추가적으로 사용한다.
블룸 필터는 키가 데이터베이스에 존재하지 않음을 알려준다.

#### 블룸 필터
>원소가 집합에 속하는지 검사하는 확률적 자료구조.
m비트 크기의 배열구조에 서로 다른 k개의 해쉬함수를 사용.
- 원소가 존재한다고 하고 실제로 존재하지 않는 긍정 오류는 발생할 수 있지만
- 원**소가 존재하지 않는다고 했는데 실재로 존재하는 부정 오류는 절대 발생하지 않는다.**

- SS테이블을 압축하고 병합하느 순서와 시기를 결정하는 전략에는
  - 크기 계층(size-tiered)
    큰 SS 테이블 위주로 병합
  - 레벨 컴팩션(leveled compaction)
    키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 레벨로 이동

### B트리
가장 널리 사용되는 색인 구조

SS테이블과 같이 키로 정렬된 키-값 쌍을 유지하기 때문에 키-값 검색과 범위 질의에 효율적
세그먼트를 수메가바이트 이상의 가변 크기로 나누는 LSM과 다르게 4KB 크기 등의 고정 크기 블록이나 페이지로 나누고 한번에 하나의 페이지에 읽기/쓰기를 한다.
각 페이지는 주소나 위치를 이용해 식별할 수 있다. 포인터와 비슷하지만 데이터가 디스크에 있음

한 페이지에서 하위 패이제를 참조하는 수를 분기 계수(branching factor)라고 부른다.

#### 알고리즘
- 키 값 갱신 시
  키를 포함하는 리프 페이지를 검색 -> 페이지 값 갱신 후 디스크에 기록
- 새로운 키 추가 시
  새로운 키를 포함하는 범위의 페이지를 찾아서 키와 값을 추가
  페이지에 충분한 공간이 없으면 페이지 하나를 여유공간이 있는 페이지 둘로 분리 -> 키-값 추가

항상 균형을 유지가 됨. n개의 키를 가진 B트리의 깊이는 항상 O(log n)
대부분의 데이터베이스는 B트리 깊이가 3~4 단계
`분기 계수 500의 4KB 페이지의 4단계 트리는 256TB까지 저장 가능 (500^4 * 4KB)`

데이터베이스 고장 시 고아 페이지가 발생할 수 있음.
복구할 수 있도록 쓰기 전 로그(write-ahead log. WAL, redo log)를 데이터 구조에 추가한다.
동시성 제어는 래치(latch)를 사용

#### B트리 최적화
 - 일부 DB는 WAL 유지 대신 쓰기 시 복사(copy-on-write scheme) 방식을 사용
 - 페이지에 전체 키 대신 키를 축약해서 저장
 - 디스크 상 순차 배치하려고 시도하지만 트리가 커지면 순서를 유지하기 어렵다. 
    LSM 트리는 병합 과정엘서 큰 세그먼트를 한번에 쓰기 때문에 순차 저장을 유지하기 쉽다
 - 트리에 포인터를 추가
 - 프랙탈 트리같은 B트리 변형은 디스크 찾기를 줄이기 위해 LSM 개념을 빌림
   (기하학의 프랙탈 아님)

## B트리와 LSM 트리 비교
 - 경험적으로 LSM 트리는 쓰기에서 빠르고 B트리는 읽기에서 빠르다고 함
 - LSM 트리는 컴팩션 단계에서 여러 데이터 구조와 SS테이블을 확인하기 때문에 읽기가 느림

### 쓰기 증폭 (write amplification)
 - 데이터베이스에 쓰기 한번이 데이터베이스 수명 동안 디스크에 여러번 쓰기를 야기하는 효과
 - 쓰기 횟수가 제한된 SSD의 경우 주요 고려사항

#### LSM 트리의 장점
 - 상대적으로 쓰기 증폭이 낮음. 순차적으로 컴팩션된 SS 테이블 파일을 쓰기 때문
    (HDD에서 월등한 성능차이)
 - 압축률이 더 좋다
 - 페이지 지향적이지 않고 주기적으로 파편화를 없애기 위해 SS테이블을 다시 기록하기 때문에 오버헤드가 더 낮다

#### LSM 트리의 단점
 - 컴팩션 과정이 때로 읽기/쓰기 성능에 영향을 줌. 성능 예측이 어렵
 - 컴팩션을 위한 쓰기 대역폭이 필요함. DB가 커질수록 대역폭 사용량이 늘어남
 - 유입속도를 조절해야 하고 명시적인 모니터링이 필요함

#### B트리 장점
 - 각 키가 색인 한곳에만 존재. 트랜잭션 시맨틱(semantic)을 제공하는 DB에 유리
 - B트리 색인에는 트리에 직접 잠금을 포함시킴
 - LSM보다 성능 예측이 쉬움

#### B트리 단점
 - B트리 색인은 WSL과 트리 페이지에 데이터를 최소 2번 저장해야 한다
 - LSM 보다 디스크를 많이 씀. (채워지지 않은 페이지 데이터로 인해)

## 기타 색인 구조
보조 색인(secondary index)를 사용하는 경우 B트리 LSM 모두 사용할 수 있다.

색인에서 키는 질의가 검색하느 대상이지만 값은 2가지중 하나에 해당
 - 질문의 실제 로우(문서, 정점)
 - 참조. (로우가 저장된 곳을 힙 파일이라고 함. 순서 없이 저장)

각 색인은 힙파일에서 위치만 참조하고 실제 데이터는 일정한 곳에 유지

#### 힙파일 접근 방식
힙파일 접근 방식은 키를 변경하지 않고 값을 갱신할 때 효율적
새로운 값이 기존보다 많은 공간을 필요로 하는 겨우 충분한 공간으로 이동해야 한다.
이 경우 모든 색인을 새로운 위치를 가리키게 갱신하거나 이전 힙 위치에 전방향 포인터를 넘겨야 한다.

#### 클러스터드 색인(clustered index)
 색인에서 힙 파일로 다시 이동하는건 읽기 성능에 불이익이 크기 때문에 색인된 로우를 저장하는 것
 ex) InnoDB 저장소 엔진에서는 PK는 항상 클러스터드 색인. 보조 색인은 기본키를 참조

#### 커버링 색인 (covering index) / 포괄열이 있는 색인 (index with included column)
 색인 안에 테이블 칼럼 일부를 저장. 일부 질의에 응답이 가능
 (색인이 질의를 커버하기 때문에 커버링 색인이라고 함)

### 다중 칼럼 색인

#### 결합 색인(concatenated index)
하나의 칼럼에 다른 칼럼을 추가하는 방식.
하나의 키에 여러 필드를 단순히 결합.
`ex) 성, 이름을 키로 하는 종이 전화번호부와 유사`

#### 다차원 색인
특정 위도와 경도 사이에 있는 레스토랑을 찾는 쿼리가 있다고 가정하면
B트리나 LSM 트리 색인으로는 효율적이지 않음.

대안 1)
 이차원 위치 공간 채움 곡선(space-filling curve)를 이용햐 단일 숫자로 반환 후 사용
대안 2)
 R 트리처럼 전문 공간 색인을 사용

#### 전문 검색과 퍼지(fuzzy) 색인
틀린 단어와 같이 유사한 키에 대해서 검색하는 경우 사용하는 색인

## 인메모리 데이터베이스
MemCached 처럼 캐쉬용으로 사용하는 DB가 있지만 최근 인메모리 DB는 지속성을 목표로 함
 - 특수 하드웨어를 사용
 - 디스크에 변경 사항의 로그 기록
 - 디스크에 주기적으로 스냅샷을 기록
 - 다른 장비에 인메모리 상태 복제 (클러스터링)

**NVM(non-volatile momory) 기술 발전에 따라 변화 가능성이 있음**

## 트랜잭션 처리나 분석
### OLTP (online transation processiong)
 범용적으로 쓰이는 대화식 접근 패턴

### OLAP (online analytic processing)
DB를 데이터 분석에 많이 사용하게 됨.
경영진의 의사결정을 돕거나 보고서를 작성할 때 사용하는 정보들 (business intelligence)
 ex) 1월 매장별 총 수익, 프로모션 기간 동안의 바나나 판매량
이러한 데이터베이스 사용 패턴을 트랜잭션 처리와 구분해 OLAP 라고 함

#### OLTP 특성
 주요 읽기 패턴 : 질의당 적은 수의 레코드를 키 기준으로 가져옴
 주요 쓰기 패턴 : 임의 접근. 사용자 입력을 낮은 시간으로 기록
 주요 사용처 : 웹 어플리케이션을 통한 최종ㄹ 사용/소비자
 데이터 표현 : 데이터의 최산 상태(현재 시점)
 데이터셋 크기 : 기가에서 테라바이트

#### OLAP 특성
 주요 읽기 패턴 : 많은 레코드에 대한 집계
 주요 쓰기 패턴 : 대규모 불러오기(bulk import, ETL) 또는 이벤트 스트림
 주요 사용처 : 의사결정 지원. 통계
 데이터 표현 : 시간이 지나며 일어난 이벤트 이력
 데이터셋 크기 : 테라바이트레서 페타바이트

>ETL : extraction, transformation, loading

### 데이터 웨어하우징
여러 OLTP 에서 사용하는 데이터를 ETL로 개별 데이터 웨어하우스에 쌓는다.

### OLTP DB와 데이터 웨어하우스의 차이점
데이터 웨아하우스의 데이터 모델은 일반적인 관계형 모델을 사용한다.
표면적으로 데이터 웨어하우스와 관계형 OLTP DB는 둘 다 SQL 질의 인터페이스를 지원하기에 비슷해보이지만 내부는 각각 질의 패턴에 맞게 최적화 되어 있음.

### 분석형 스키마
 많은 데이터 웨어하우스는 별 모양 스키마(star schema. 차원 모델링 dimensional modeling) 이라는 정형화된 방식 사용

대기업에서 사용하는 수십 페타바이트의 트랜잭션 내역 중 대부분은 사실 테이블이다.
사실 테이블의 칼럼은 다른 테이블을 가리키는 외래 키 참조
사실 테이블의 각 로우는 이벤트의 속성을 육하원칙으로 나타낸것
쇼핑몰을 예로 고객이 여러 다양한 제품을 동시게 구매하면 사실테이블에는 개별 로우로 표시됨

별 모양 스키마라는 이름은 테이블 관계과 시각화 될 때 사실 테이블이 가운데에 있고 차원 테이블이 둘러싸고 있는 모습에서 비롯됨.

## 칼럼 지향 저장소
사실 테이블은 칼럼이 보통 	100개 이상이지만 일반적인 데이터 하우스의 질의는 한 번에 4~5개 칼럼만 접근한다.

#### 효울적인 방법은?

대부분의 OLTP DB는 로우 지향 방식으로 데이터를 배치.
테이블 한 로우의 모든 값은 서로 인접하게 저장된다.

칼럼 지향 저장소는 모든 값을하나의 로우에 함께 저장하지 않고,
각 칼럼 별로 모든 값을 함께 저장한다.

#### 칼럼 압축
칼럼은 많은 값이 반복되어 나타내는 경향이 있기 때문에 비트맵 부호화로 압축한다.

비트맥 색인은 데이터 웨어하우스에서 일반적으로 사용되는 질의 종류에 매우 적합

```
ex)
 WHERE product_sk IN (30, 68, 69)
    > 3개 비트맵에 대해 OR 연산
 WHERE product_sk = 31 AND stroe_sk = 3
     > 2개 비트맵에 대해 AND 연산
```

>  칼럼 지향 저장소와 칼럼 패밀리
 카산드라와 HBase는 빅테이블로부터 내려오는 칼럼 패밀리라는 개념이 있음.
각 칼럼 패밀리 안에는 로우 키에 따라 로우와 모든 칼럼을 함께 저장함.
빅테이블 모델은 여전히 대부분 로우 지향

#### 메모리 대역폭과 벡터화 처리
수백만 로우를 스캔해야하는 데이터 웨어하수으의 질의는 디스크에서메모리로 데이터를 가져오는 대역폭이 큰 병목이다. 하지만 메모리에서 CPU 캐시로 가는 대역폭도 효울적으로 사용해야 한다.

#### 벡터화 처리 (vectorized processing)
 - 분석용 데이터베이스 개발자는 메인 메모리에서 CPU 캐시로 가는 대역폭을 효율적으로 사용
 - CPU 명령 처리 파이프라인에서 분기 예측 실패(branch misprediction)와 버블(buble)을 피하기
 - 최신 CPU에서 SIMD(single-instruction-multi-data) 명령을 사용
 - CPU L1 캐시에 맞도록 덩어리를 나누어서 가져온다.
    이 작업을 타이트 루프(tight loop)에서 반복한다.

#### 칼럼 저장소의 순서 정렬
자주 사용하는 칼럼으로 정렬하면  칼럼 압축이나 질의에 이득이다.
우선순위를 두고 1~3번 째 까지 정렬 해서 사용한다.

#### 다양한 순서 정렬
다양한 질의는 서로 다른 정렬 순서의 도움을 받으므로 같은 데이터를 다양한 방식으로 정렬해 저장한다. 레플리카를 만들 때 서로 다른 기준으로 정렬한다.
(C-스토어에 소개됐고 상업용 데이터 웨어하우스인 버티카에 채택됐다)

칼럼 지향 저장은 로우 지향 저장에서 사용하는 힙 파일이나 클러스터드 색인과 다르게
포인터가 아닌 값을 포함하는 점이 다른점이다.

#### 칼럼 지향 저장소에 쓰기
칼럼 지향 저장소, 압축, 정렬은 모두 읽기 성능을 향상하지만
쓰기를 어렵게 한다는 단점이 있음.

B트리 같은 제자리 갱신(update-in-place) 접근 방식은 압축된 칼럼에서는 불가능
로우는 칼럼 안에 위치에 따라 식별되므로 삽입은 모든 칼럼을 일관되게 갱신해야함

LSM 트리를 쓰면 해결이 가능.
모든 쓰기는 먼저 인메모리 저장소로 이동해 정렬된 구조에 추가. 디스크에 쓸 준비를 함
충분한 쓰기를 모으면 디스크의 칼럼 파일에 병합하고 대량으로 새로운 파일에 기록

질의는 디스크의 칼럼 데이터와 메모리의 최근 쓰기를 모두 조사해 두 가지를 결합해야 한다.

집계: 데이터 큐브와 구체화 뷰
모든 데이터 웨어하우스가 칼럼 저장이 필수는 아님.

#### 구체화 집계(materialized aggregate)
SQL의 집계함수(max, count, sum 등) 같은 집계 함수를 자주 사용할 때 
캐시를 사용해서 성능을 향상 시키는 방식

#### 구체화 뷰(materialized view)
관계형 데이터 모델에서는 이런 캐시를 표준(가상) 뷰로 정의한다.
 - 구체화 뷰는 디스크에 기록된 질의 결과의 실제 복사본
 - 가상 뷰는 질의를 작성하는 단축키일 뿐

원본 데이터를 변경하면 구체화 뷰를 갱신해야 한다.
